- [v] Запустить 2 виртуальных COM-порта
    С ходу не запустилось, ошибка в дискрипторах, надо разбираться
    - [v] Закончился буфер для дискрипторов, нужно было добавить фичу `"control-buffer-256"` для крейта `usb-device`
- [v] Получить настройки порта от хоста
    - [v] Скорость, биты, стоп-биты, четность
    - [x] Контроль потока rts/cts не делает то что надо, придется руками управлять RE/DE
- [v] Создать интерфейс для I2C-моста
    - [x] Маскируемся под FT260
        - [v] Удалось зарегистрировать просто мышку
        - [v] Получить полный дискриптор репорта FT260
            Он огромный, надо выделить только то, что касается I2C
            Используются только 2 контрол-репорта:
            - 0xA1 - Управление
            - 0xC0 - Запрос статуса
            Используются только 2 репорта данных:
            - 0xC2 - Чтение
            - 0xD0 - Запись
        - [v] Вывод запросов i2c в консоль
        FAIL: `usbd-hid` Не поддеривает чтение `Feature`-репортов, поэтому готовый драйвер как на FT260 не получится приспособить. Придется сделать реализацию подобную CH340 но запросы просовываьт в `Data`-репортах HID'а
    - [v] Реализация подобная CH340
        - [v] Создать дискриптор устройства
            После долгих мучений было принято решение пихать все данные через 1 репорт а сам протокол - как у CH340, кырезать все что касается GPIO, SPI и UART
        - [v] Полностью отказываемся от совместимости с CH340. 
            Суть в том, что со стороны ГУЯ идет 4 запроса
            - I2C_Detect()
            - ReadData()
            - WriteData()
            - SetSpeed()
            И это очень близко в HAL-Api
            - embedded_hal::blocking::i2c::Write и embedded_hal::blocking::i2c::Read
            - Детект сделаем руками.
            - Скорость можно пока вообще не поддерживать.
    - [v] Отладка взаимодействия с реальным устройством
        DB02 Почти работает.
        - [v] Починить чтение HASH и Version
        - [v] Смена скорости
        - [v] Сброс шины
    - [v] Документирование протокола I2C-моста в README.md
- [v] Опрос датчиков I2C
    - [v] Сканер шины
    - [v] Обнаружение присутствия датчика
    - [v] Probe, определение типа датчика
    - [v] Read
    - [v] Render as debug output
- [v] Heap
    - via `embedded-alloc`
- [v] Дисплей
    - [v] Подключение
    - [v] Перевернуть на 90 градусов
- [v] Измерение токов потребления
    - [v] Симуляция, поскольку реальные `INA219` не отсутствуют на макете
        - Не удается сделать врапер i2c полностью платформо-независимым.
    - [v] Обрыв соединения если ток менее 0.1 мА, заставка -> мониторинг тока.
    - [v] Мониторинг тока

- [v] Modbus bridge
    - [v] Анализ сообщений от ПК. К передаче на UART допускаются только валидные сообщения.
    - [v] Установка скорости/паритета/стоп-битов
    - [v] Передача сообщений на UART
    - [v] Управление RE/DE
    - [v] 2 UART одновременно
    - [v] Ответ от датчика
    - [v] Сборка ответ в буфер
    - [v] Передача ответа на ПК
    Текущая черновая реализация работает нестабильно, требуется глубокая переработака с дроблением на более специализированные сущности.
    - [v] Обернуть UART в менеджер который будет следить за полудуплексным режимом и управлять RE/DE
    - [v] Прием из Virtual COM длинных сообщений, более 1 пакета путем прогнозирования их длины по коду функции (в первом пакете)
    - [v] Декодирование запросов в `modbus_core::rtu::server::decode_request()`
    - [v] Запрос оборачивается в статус и кладется в общую очередь на отправку.

- [v] Опрос датчиков через подсистему `Modbus`
    - [v] Дефолтные настройки портов `8N1@57600`
    - [v] Игнорировать настройки порта, если они изменены с компа.
    - [v] Начать поиск датчиков аналогично подсистеме `i2c`. 
    - [v] 1 дефолтный способ скнирования, если кто-то ответил, обходим известные датчики и пробуем подходит или нет.